{% extends "site_base.html" %}

{% load i18n static compress %}

{% block head_title %}Kunnallisvaaliehdokkaiden ennakkorahoitusilmoitukset{% endblock %}

{% block extra_style %}
<link rel="stylesheet" href="http://leaflet.cloudmade.com/dist/leaflet.css" />
<style>


#map {
	width: 450px;
	height: 650px;
	
	margin: 10px 0 40px;
}

#party-graph {
	width: 400px; 
	height: 300px;
}

#party-legend {
	position: absolute; 
	left: 400px; 
	top: 50px;
}

#candidate-graph {
	width: 400px; 
	height: 300px;
}

#candidate-legend {
	position: absolute; 
	left: 400px; 
	top: 50px;
}

.leaflet-container {
    background: none repeat scroll 0 0 #F5F5F5;
}

.info {
	padding: 6px 8px;
	font: 14px/16px Arial, Helvetica, sans-serif;
	background: white;
	background: rgba(255,255,255,0.8);
	box-shadow: 0 0 15px rgba(0,0,0,0.2);
	border-radius: 5px;
	right: 0px;
}

.info h4 {
	margin: 0 0 5px;
	color: #777;
}
.legend {
	text-align: left;
	line-height: 18px;
	color: #555;
}
.legend i {
	width: 18px;
	height: 18px;
	float: left;
	margin-right: 8px;
	opacity: 0.7;
}

.graph-container {
	margin: 40px 0 40px 0;
}

#party-legend .highlight {
	background-color: khaki;
}
#party-legend td {
	white-space: nowrap;
}

</style>
{% endblock %}

{% block extra_script %}
{% compress js %}
<script type="text/javascript" src="{% static "js/underscore.js" %}"></script>
{% endcompress %}
{% compress js %}
<script type="text/javascript" src="{% static "js/spin.min.js" %}"></script>
{% endcompress %}

{% compress js %}
<script type="text/javascript" src="{% static "js/jquery.flot.js" %}"></script>
<script type="text/javascript" src="{% static "js/jquery.flot.time.js" %}"></script>
<script type="text/javascript" src="{% static "js/jquery.flot.crosshair.js" %}"></script>
{% endcompress %}

{% compress js %}
<script type="text/javascript" src="{% static "js/leaflet.js" %}"></script>
{% endcompress %}

{% compress js %}
<script type="text/coffeescript">
muni_dict = {{ muni_json|safe }}

$.ajax '/api/v1/municipality/'
  dataType: 'json'
  data:
    limit: 1000
    format: 'geojson'
  error: (args1, args2) ->
    alert "{% trans "Communication with server failed" %}"
  success: (geojson) ->
    for feat in geojson.features
      muni = muni_dict[feat.id]
      # If the muni is not found, it doesn't have the stats.
      # We don't render those.
      if not muni
        feat.properties.render = false
      else
        feat.properties.render = true
        _.extend(feat.properties, muni)
    geojson.features = _.filter(geojson.features, (feat) ->
      return feat.properties.render
    )
    handle_geojson(geojson)

PARTY_COLORS =
  'RKP': "#FFD87D",
  'KOK': "#C7DDF3",
  'KESK': "#9FD18B",
  'KD': "#CCCCCC",
  'PS': "#69B3E3",
  'VIHR': "#DDE89A",
  'SDP': "#F9C0C7",
  'VAS': "#EC008C",
  'PIR': "#888888",
  'SKP': "red",

cumulative_data = []
num_data = []

render_plots = (party_list) ->
  cumulative_data = []
  num_data = []
  num_ticks = []
  i = 0
  if party_list.length > 10
    do_filtering = true

  for p in party_list
    if not do_filtering or p.num_candidates > 40
      args =
        label: p.code
        data: [[i, p.num_candidates]]
      if p.code of PARTY_COLORS
        args.color = PARTY_COLORS[p.code]
      num_data.push args
      num_ticks.push [i, p.code]
      i++

    data = []
    # Convert data into percentages
    for dd in p.disclosure_data
      perc = dd[1] / p.num_candidates
      data.push([dd[0], perc])
    if not data.length
      continue
    # Include only parties that actually have candidates
    # submitting budgets.
    last_percent = data[data.length-1][1]
    if do_filtering and last_percent == 0.0
      continue
    args =
      data: data
      label: p.code + " " + (last_percent*100).toFixed(1) + " %"
    if p.code of PARTY_COLORS
      args.color = PARTY_COLORS[p.code]
    args.party = p
    cumulative_data.push args 

  if not cumulative_data.length
    $("#party-graph").unbind("plothover")
    $("#party-graph").html("<h4>Ei ennakkoilmoituksia.</h4>")
    $("#party-legend").html("")
  else
    # Sort based on percentage
    cumulative_data = _.sortBy cumulative_data, (fd) ->
      return 1 - fd.data[data.length-1][1]
    plot = $.plot $("#party-graph"), cumulative_data,
      series:
        lines:
          show: true
          lineWidth: 3
      crosshair:
        mode: "x"
      xaxis:
        mode: "time"
        timeformat: "%d.%m."
        show: true
      yaxis:
        tickFormatter: (num, obj) ->
          return "" + (num * 100).toFixed(0) + " %"
        show: true
        min: 0
        max: 1
      grid:
        hoverable: true
        borderWidth: 0
      legend:
        container: $("#party-legend")

  $.plot $("#candidate-graph"), num_data,
    series:
      bars:
        show: true
        align: "center"
    grid:
      show: true
      borderWidth: 0
    legend:
      show: false
    xaxis:
      ticks: num_ticks

  $("#party-legend .legendLabel").each ->
    $(@).css('width', $(@).width())

  $("#party-graph").unbind("plothover")
  last_position = null
  last_item = null
  update_legend_timeout = null
  update_legend = ->
    update_legend_timeout = null
    leg_el = $("#party-legend")
    leg_el.find("tr").removeClass("highlight")

    dataset = cumulative_data
    # find the nearest point, x-wise
    series = dataset[0]
    for i in [0..series.data.length-1]
      if series.data[i][0] > last_position.x
        break
    if i >= series.data.length
      i = series.data.length - 1
    nearest_data = i

    for i in [0..dataset.length-1]
      series = dataset[i]
      el = leg_el.find(".legendLabel").eq(i)
      perc = series.data[nearest_data][1] * 100
      text = series.party.code + " " + perc.toFixed(1) + " %"
      el.html(text)

    if not last_item
      return
    party = cumulative_data[last_item.seriesIndex].party
    num_submitted = party.disclosure_data[last_item.dataIndex][1]
    $("#party-legend tr").eq(last_item.seriesIndex).addClass("highlight")
  
  $("#party-graph").bind("plothover", (event, pos, item) ->
    last_position = pos
    last_item = item
    if not update_legend_timeout
      update_legend_timeout = setTimeout(update_legend, 50)  
  )

update_plots = (muni_id, muni_name) ->
  $("#party-graph").html('')
  spinner = new Spinner().spin($("#party-graph")[0])
  if muni_id
    data = {municipality: muni_id}
  else
    data = {}
  $.ajax '/candidates/fetch-party-budget/'
    dataType: 'json'
    data: data
    error: (args1, args2) ->
      alert "{% trans "Communication with server failed" %}"
    success: (data) ->
      spinner.stop()
      delete spinner
      party_list = data
      $(".muni-selection").html(muni_name)
      render_plots party_list

update_plots(0, "koko maa")

stored_geojson = null
handle_geojson = (json) ->
  stored_geojson = json

init_map = ->
  map = L.map('map',
    minZoom: 5,
    maxZoom: 6,
    # Some basic options to keep the map still and prevent
    # the user from zooming and such.
    scrollWheelZoom: true,
    touchZoom: true,
    doubleClickZoom: true,
    zoomControl: true,
    dragging: true
  );

  #cloudmade = L.tileLayer('http://{s}.tile.cloudmade.com/{key}/{styleId}/256/{z}/{x}/{y}.png',
  #  attribution: 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',
  #  key: 'BC9A493B41014CAABB98F0471D759707',
  #  styleId: 22677
  #).addTo(map);

  # control that shows state info on hover
  info = L.control();

  info.onAdd = (map) ->
    @._div = L.DomUtil.create('div', 'info');
    @.update();
    @._div;
  info.update = (props) ->
    s = ''
    if props
      perc = props.num_submitted / props.num_candidates
      s += '<b>' + props.name + '</b> (' + props.num_candidates + ' ehdokasta)' + '<br />' + (perc * 100).toFixed(0) + ' % tehnyt ennakkoilmoituksen'
    else
      s += 'Vie osoitin kunnan päälle'
    @._div.innerHTML = s
  info.addTo(map);
  # get color depending on population density value
  get_color = (d) ->
    if d > 0.40
      c = '#1A9850'
    else if d > 0.30
      c = '#91CF60'
    else if d > 0.20
      c = '#D9EF8B'
    else if d > 0.10
      c = '#FEE08B'
    else if d > 0.01
      c = '#FC8D59'
    else
      c = '#D73027'
    return c

  style = (feature) ->
    props = feature.properties
    perc = props.num_submitted / props.num_candidates
    return {
      fillColor: get_color(perc)
      weight: 1
      color: '#666'
      opacity: 0.6
      fillOpacity: 1.0
    }
  highlight_feature = (e) ->
    layer = e.target;

    layer.setStyle
      weight: 5,
      color: '#666',
      dashArray: '',
      fillOpacity: 0.7
    if (!L.Browser.ie && !L.Browser.opera)
      layer.bringToFront()
    info.update(layer.feature.properties)

  reset_highlight = (e) ->
    geojson.resetStyle(e.target)
    info.update()

  on_each_feature = (feature, layer) ->
    zoom_to_feature = (e) ->
      update_plots(feature.id, feature.properties.name)
      #map.fitBounds(e.target.getBounds())

    layer.on
      mouseover: highlight_feature,
      mouseout: reset_highlight,
      click: zoom_to_feature

  legend = L.control({position: 'bottomright'})
  legend.onAdd = (map) ->
    div = L.DomUtil.create('div', 'info legend')
    grades = [0.0, 0.01, 0.10, 0.20, 0.30, 0.40]
    labels = []
    for i in [0..grades.length-1]
      from = grades[i]
      from_pr = (from * 100).toFixed(0)
      to = grades[i + 1]
      to_pr = (to * 100).toFixed(0)
      s = '<i style="background:' + get_color(from + 0.01) + '"></i> ' + from_pr + ' % '
      if to
        s += ' &ndash; ' + to_pr + ' % '
      else
        s += '+'
      labels.push(s)
    div.innerHTML = labels.join('<br>')
    return div
  legend.addTo(map)

  geojson = {}
  handle_geojson = (json_data) ->
    geojson = L.geoJson(json_data,
      style: style,
      onEachFeature: on_each_feature
    ).addTo(map)
    bounds = geojson.getBounds();
    # Adjust the bounds manually
    offset = 6
    bounds["_southWest"]["lat"] = bounds["_southWest"]["lat"] - offset
    bounds["_southWest"]["lng"] = bounds["_southWest"]["lng"] - offset
    bounds["_northEast"]["lat"] = bounds["_northEast"]["lat"] + offset
    bounds["_northEast"]["lng"] = bounds["_northEast"]["lng"] + offset
    map.fitBounds(bounds).setMaxBounds(bounds)
    map.panTo([66.0, 27.8])
  if stored_geojson
    handle_geojson(stored_geojson)
 
# The code below is run after the HTML document has finished loading.
jQuery ->
  init_map()
</script>
{% endcompress %}
{% endblock %}

{% block body %}
  	<div class="row-fluid">
  		<div class=span12>
  		
  		  <div class="hero-unit">
  		  	<h1 style="font-size: 26px;">Kunnallisvaaliehdokkaiden 2012 ennakkorahoitusilmoitukset</h1>
  		  	<p>
  		  		Kunnallisvaaliehdokkaiden on mahdollista tehdä ennakkoilmoitus 
  		  		vaalikampanjansa rahoituksesta jo ennen mahdollista valituksi 
  		  		tulemista. Kuinka moni on valmis avaamaan vaalirahoituksensa 
  		  		etukäteen ja kuinka ennakkoilmoituksia on täytetty eri 
  		  		puolueissa?
  		    </p>
  		  </div>
  		
  		  <p>
		  	Tämän sivun kuvaajat perustuvat <a href="http://www.vaalirahoitusvalvonta.fi/fi/index/vaalirahailmoituksia.html">
		  	Puolue- ja vaalirahoitusvalvonnan</a> rekisteröimiin vaalirahoituksen
		  	ennakkoilmoituksiin. Ennakkoilmoiksen tekeminen on vapaaehtoista ja 
		  	varsinaisen vaalirahoitusilmoituksen tekevät vaalien tuloksen 
		  	vahvistamisen jälkeen valitut ja vaalien tulosta vahvistettaessa 
		  	varaedustajaksi määrätyt. 
		  </p>
		  
		  <p>
		  	Ennakkoilmoitukset on koostettu hakemalla <a href="http://www.vaalirahoitusvalvonta.fi/fi/index/vaalirahailmoituksia/raportit/Tietoaineistot.html.stx">
		    VRV:n julkaisemia tietoaineistoja</a> automaattisesti ja 
		    päivittämällä tiedot Datavaalien tietokantaan.
		  </p>
		  
		  <p>
		  	Tilanne on viimeksi päivitetty <strong>{{ timestamp|date:"d.m.Y H:i" }}</strong>, jolloin 
		  	ennakkoilmoituksen on jättänyt <strong>{{ num_submitted }}</strong> ehdokasta. 
		  </p>
		
	    </div>
	 </div>
		 
		
	 	<div class="row-fluid graph-container">
	 	  <div class="span6">
	 	  	<h5>Ennakkoilmoittaneiden osuus kunnittain</h5>
	 		<div id="map"></div>
		  </div>
		  
		  <div class="span6">
			  <div style="position: relative; margin: 10px 0 10px 0;">
			  	<h5>Ennakkoilmoitusten kertyminen, <span class="muni-selection"></span></h5>
			    <div id="party-graph"></div>
			    <div id="party-legend"></div>
			  </div>
		  </div>
		  
		  <div class="span6">
			  <div style="position: relative">
			  	<h5>Ehdokkaiden lukumäärä puolueittain, <span class="muni-selection"></span></h5>
			    <div id="candidate-graph"></div>
			    <div id="candidate-legend"></div>
			  </div>
		  </div>
		</div>
  
  <div class="row-fluid">
	  
	  <div class="span4">		
	  	<h4>Ennakkoilmoituksen tehneiden ehdokkaiden osuus kunnittain</h4>  	
	  	
	  	<p>
	  		Vasemmalla oleva kartta näyttää prosentein kuink suuri osuus 
	  		kunkin kunnan ehdokkaista on tehnyt vaalirahoituksen 
	  		ennakkoilmoituksen. Viemällä osoittimen kunnan päälle päivittyvät
	  		oikealla olevat kuvaajat kyseisen kunnan tiedoilla. 
	  	    Jotkin kunnat puuttuvat kokonaan kartalta, sillä niissä ei ole 
	  		virallisesti yhtään ehdokasta usein tulevien kuntaliitosten takia. 
	  	</p>
	 </div> 	
	 
	 <div class="span4"> 	
		<h4>Milloin ehdokkaat ovat ilmoituksia jättäneet?</h4>
		  
		<p>
	  		Oikealla ylhäällä oleva kuvaaja kertoo, kuinka ennakkoilmoituksia 
	  		on kertynyt eri puolueiden ehdokkailta kunnallisvaalien lähestyessä.
	  		Ilmoituksia alettiin seurata 7.10.2012 ja seurantaa jatketaan
	  		vaaleihin asti. Vaalien jälkeen sivulle päivitetään valituksi 
	  		tulleiden vaalirahoitustiedot.
		</p>
	 </div>
		
	 <div class="span4">	
		<h4>Kuinka paljon ehdokkaita on puolueittain?</h4>
		  
		<p>
	  		Oikealla alhaalla oleva kuvaaja näyttää kuinka paljon ehdokkaita
	  		eri puolueilla on maanlaajuisesti ja kunnittain. 
		</p>
     </div>
	</div>
	 
	<div class="row-fluid">
	 <div class="span12">
		<hr />
		<h4>Löysitkö virheen tai keksitkö parannettavaa?</h4>
		  
		<p>
	  		Voit avata uuden issuen tai kommentoida vanhoja datavaalien 
	  		<a href="https://github.com/kansanmuisti/datavaalit/issues?state=open">
	  			GitHub-sivuilla</a>. 
		</p>
	 </div> 	
  </div>
{% endblock %}

