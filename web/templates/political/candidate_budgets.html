{% extends "site_base.html" %}

{% load i18n static compress %}

{% block head_title %}Kunnallisvaaliehdokkaiden ennakkorahoitusilmoitukset{% endblock %}

{% block extra_style %}
<link rel="stylesheet" href="http://leaflet.cloudmade.com/dist/leaflet.css" />
<style>


#map {
	width: 450px;
	height: 650px;
	
	margin: 10px 0 40px;
}

#party-graph {
	width: 400px; 
	height: 300px;
}

#party-legend {
	position: absolute; 
	left: 400px; 
	top: 50px;
}

#candidate-graph {
	width: 400px; 
	height: 300px;
}

#candidate-legend {
	position: absolute; 
	left: 400px; 
	top: 50px;
}

.leaflet-container {
    background: none repeat scroll 0 0 #F5F5F5;
}

.info {
	padding: 6px 8px;
	font: 14px/16px Arial, Helvetica, sans-serif;
	background: white;
	background: rgba(255,255,255,0.8);
	box-shadow: 0 0 15px rgba(0,0,0,0.2);
	border-radius: 5px;
	right: 0px;
}

.info h4 {
	margin: 0 0 5px;
	color: #777;
}
.legend {
	text-align: left;
	line-height: 18px;
	color: #555;
}
.legend i {
	width: 18px;
	height: 18px;
	float: left;
	margin-right: 8px;
	opacity: 0.7;
}

.graph-container {
	margin: 40px 0 40px 0;
}

#party-legend .highlight {
	background-color: khaki;
}
#party-legend td {
	white-space: nowrap;
}

</style>
{% endblock %}

{% block extra_script %}
{% compress js %}
<script type="text/javascript" src="{% static "js/underscore.js" %}"></script>
{% endcompress %}
{% compress js %}
<script type="text/javascript" src="{% static "js/spin.min.js" %}"></script>
{% endcompress %}

{% compress js %}
<script type="text/javascript" src="{% static "js/jquery.flot.js" %}"></script>
<script type="text/javascript" src="{% static "js/jquery.flot.time.js" %}"></script>
<script type="text/javascript" src="{% static "js/jquery.flot.crosshair.js" %}"></script>
{% endcompress %}

{% compress js %}
<script type="text/javascript" src="{% static "js/leaflet.js" %}"></script>
{% endcompress %}

{% compress js %}
<script type="text/coffeescript">
muni_dict = {{ muni_json|safe }}

$.ajax '/api/v1/municipality/'
  dataType: 'json'
  data:
    limit: 1000
    format: 'geojson'
  error: (args1, args2) ->
    alert "{% trans "Communication with server failed" %}"
  success: (geojson) ->
    for feat in geojson.features
      muni = muni_dict[feat.id]
      # If the muni is not found, it doesn't have the stats.
      # We don't render those.
      if not muni
        feat.properties.render = false
      else
        feat.properties.render = true
        _.extend(feat.properties, muni)
    geojson.features = _.filter(geojson.features, (feat) ->
      return feat.properties.render
    )
    handle_geojson(geojson)

PARTY_COLORS =
  'RKP': "#FFD87D",
  'KOK': "#C7DDF3",
  'KESK': "#9FD18B",
  'KD': "#CCCCCC",
  'PS': "#69B3E3",
  'VIHR': "#DDE89A",
  'SDP': "#F9C0C7",
  'VAS': "#EC008C",
  'PIR': "#888888",
  'SKP': "red",

cumulative_data = []
num_data = []

render_plots = (party_list) ->
  cumulative_data = []
  num_data = []
  num_ticks = []
  i = 0
  if party_list.length > 10
    do_filtering = true

  for p in party_list
    if not do_filtering or p.num_candidates > 40
      args =
        label: p.code
        data: [[i, p.num_candidates]]
      if p.code of PARTY_COLORS
        args.color = PARTY_COLORS[p.code]
      num_data.push args
      num_ticks.push [i, p.code]
      i++

    data = []
    # Convert data into percentages
    for dd in p.disclosure_data
      perc = dd[1] / p.num_candidates
      data.push([dd[0], perc])
    if not data.length
      continue
    # Include only parties that actually have candidates
    # submitting budgets.
    last_percent = data[data.length-1][1]
    if do_filtering and last_percent == 0.0
      continue
    args =
      data: data
      label: p.code + " " + (last_percent*100).toFixed(1) + " %"
    if p.code of PARTY_COLORS
      args.color = PARTY_COLORS[p.code]
    args.party = p
    cumulative_data.push args 

  if not cumulative_data.length
    $("#party-graph").unbind("plothover")
    $("#party-graph").html("<h4>Ei ennakkoilmoituksia.</h4>")
    $("#party-legend").html("")
  else
    # Sort based on percentage
    cumulative_data = _.sortBy cumulative_data, (fd) ->
      return 1 - fd.data[data.length-1][1]
    plot = $.plot $("#party-graph"), cumulative_data,
      series:
        lines:
          show: true
          lineWidth: 3
      crosshair:
        mode: "x"
      xaxis:
        mode: "time"
        timeformat: "%d.%m."
        show: true
      yaxis:
        tickFormatter: (num, obj) ->
          return "" + (num * 100).toFixed(0) + " %"
        show: true
        min: 0
        max: 1
      grid:
        hoverable: true
        borderWidth: 0
      legend:
        container: $("#party-legend")

  $.plot $("#candidate-graph"), num_data,
    series:
      bars:
        show: true
        align: "center"
    grid:
      borderWidth: 0
    legend:
      show: false
    xaxis:
      ticks: num_ticks

  $("#party-legend .legendLabel").each ->
    $(@).css('width', $(@).width())

  $("#party-graph").unbind("plothover")
  last_position = null
  last_item = null
  update_legend_timeout = null
  update_legend = ->
    update_legend_timeout = null
    leg_el = $("#party-legend")
    leg_el.find("tr").removeClass("highlight")

    dataset = cumulative_data
    # find the nearest point, x-wise
    series = dataset[0]
    for i in [0..series.data.length-1]
      if series.data[i][0] > last_position.x
        break
    if i >= series.data.length
      i = series.data.length - 1
    nearest_data = i

    for i in [0..dataset.length-1]
      series = dataset[i]
      el = leg_el.find(".legendLabel").eq(i)
      perc = series.data[nearest_data][1] * 100
      text = series.party.code + " " + perc.toFixed(1) + " %"
      el.html(text)

    if not last_item
      return
    party = cumulative_data[last_item.seriesIndex].party
    num_submitted = party.disclosure_data[last_item.dataIndex][1]
    $("#party-legend tr").eq(last_item.seriesIndex).addClass("highlight")
  
  $("#party-graph").bind("plothover", (event, pos, item) ->
    last_position = pos
    last_item = item
    if not update_legend_timeout
      update_legend_timeout = setTimeout(update_legend, 50)  
  )

update_plots = (muni_id, muni_name) ->
  $("#party-graph").html('')
  spinner = new Spinner().spin($("#party-graph")[0])
  if muni_id
    data = {municipality: muni_id}
  else
    data = {}
  $.ajax '/candidates/fetch-party-budget/'
    dataType: 'json'
    data: data
    error: (args1, args2) ->
      alert "{% trans "Communication with server failed" %}"
    success: (data) ->
      spinner.stop()
      delete spinner
      party_list = data
      $(".muni-selection").html(muni_name)
      render_plots party_list

update_plots(0, "koko maa")

stored_geojson = null
handle_geojson = (json) ->
  stored_geojson = json

init_map = ->
  map = L.map('map',
    minZoom: 5,
    maxZoom: 6,
    # Some basic options to keep the map still and prevent
    # the user from zooming and such.
    scrollWheelZoom: true,
    touchZoom: true,
    doubleClickZoom: true,
    zoomControl: true,
    dragging: true
  );

  #cloudmade = L.tileLayer('http://{s}.tile.cloudmade.com/{key}/{styleId}/256/{z}/{x}/{y}.png',
  #  attribution: 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',
  #  key: 'BC9A493B41014CAABB98F0471D759707',
  #  styleId: 22677
  #).addTo(map);

  # control that shows state info on hover
  info = L.control();

  info.onAdd = (map) ->
    @._div = L.DomUtil.create('div', 'info');
    @.update();
    @._div;
  info.update = (props) ->
    s = ''
    if props
      perc = props.num_submitted / props.num_candidates
      s += '<b>' + props.name + '</b> (' + props.num_candidates + ' ehdokasta)' + '<br />' + (perc * 100).toFixed(0) + ' % tehnyt ennakkoilmoituksen'
    else
      s += 'Vie osoitin kunnan päälle'
    @._div.innerHTML = s
  info.addTo(map);
  # get color depending on population density value
  get_color = (d) ->
    if d > 0.40
      c = '#1A9850'
    else if d > 0.30
      c = '#91CF60'
    else if d > 0.20
      c = '#D9EF8B'
    else if d > 0.10
      c = '#FEE08B'
    else if d > 0.01
      c = '#FC8D59'
    else
      c = '#D73027'
    return c

  style = (feature) ->
    props = feature.properties
    perc = props.num_submitted / props.num_candidates
    return {
      fillColor: get_color(perc)
      weight: 1
      color: '#666'
      opacity: 0.6
      fillOpacity: 1.0
    }
  highlight_feature = (e) ->
    layer = e.target;

    layer.setStyle
      weight: 5,
      color: '#666',
      dashArray: '',
      fillOpacity: 0.7
    if (!L.Browser.ie && !L.Browser.opera)
      layer.bringToFront()
    info.update(layer.feature.properties)

  reset_highlight = (e) ->
    geojson.resetStyle(e.target)
    info.update()

  on_each_feature = (feature, layer) ->
    zoom_to_feature = (e) ->
      update_plots(feature.id, feature.properties.name)
      #map.fitBounds(e.target.getBounds())

    layer.on
      mouseover: highlight_feature,
      mouseout: reset_highlight,
      click: zoom_to_feature

  legend = L.control({position: 'bottomright'})
  legend.onAdd = (map) ->
    div = L.DomUtil.create('div', 'info legend')
    grades = [0.0, 0.01, 0.10, 0.20, 0.30, 0.40]
    labels = []
    for i in [0..grades.length-1]
      from = grades[i]
      from_pr = (from * 100).toFixed(0)
      to = grades[i + 1]
      to_pr = (to * 100).toFixed(0)
      s = '<i style="background:' + get_color(from + 0.01) + '"></i> ' + from_pr + ' % '
      if to
        s += ' &ndash; ' + to_pr + ' % '
      else
        s += '+'
      labels.push(s)
    div.innerHTML = labels.join('<br>')
    return div
  legend.addTo(map)

  geojson = {}
  handle_geojson = (json_data) ->
    geojson = L.geoJson(json_data,
      style: style,
      onEachFeature: on_each_feature
    ).addTo(map)
    bounds = geojson.getBounds();
    # Adjust the bounds manually
    offset = 6
    bounds["_southWest"]["lat"] = bounds["_southWest"]["lat"] - offset
    bounds["_southWest"]["lng"] = bounds["_southWest"]["lng"] - offset
    bounds["_northEast"]["lat"] = bounds["_northEast"]["lat"] + offset
    bounds["_northEast"]["lng"] = bounds["_northEast"]["lng"] + offset
    map.fitBounds(bounds).setMaxBounds(bounds)
    map.panTo([66.0, 27.8])
  if stored_geojson
    handle_geojson(stored_geojson)
 
# The code below is run after the HTML document has finished loading.
jQuery ->
  init_map()
</script>
{% endcompress %}
{% endblock %}

{% block body %}
  	<div class="row-fluid">
  		<div class=span12>
  		
  		  <h1 style="font-size: 26px;">Kunnallisvaaliehdokkaiden 2012 ennakkorahoitusilmoitukset</h1>
  		
  		  <p>
		  	Tämän sivun kuvaajat perustuvat <a href="http://www.vaalirahoitusvalvonta.fi/fi/index/vaalirahailmoituksia.html">
		  	Puolue- ja vaalirahoitusvalvonnan</a> rekisteröimiin vaalirahoituksen
		  	ennakkoilmoituksiin. Ennakkoilmoiksen tekeminen on vapaaehtoista ja 
		  	varsinaisen vaalirahoitusilmoituksen tekevät vaalien tuloksen 
		  	vahvistamisen jälkeen valitut ja vaalien tulosta vahvistettaessa 
		  	varaedustajaksi määrätyt. 
		  </p>
		  
		  <p>
		  	Ennakkoilmoitukset on koostettu hakemalla <a href="http://www.vaalirahoitusvalvonta.fi/fi/index/vaalirahailmoituksia/raportit/Tietoaineistot.html.stx">
		    VRV:n julkaisemia tietoaineistoja</a> automaattisesti ja 
		    päivittämällä tiedot Datavaalien tietokantaan.
		  </p>
		  
		  <p>
		  	Tilanne on viimeksi päivitetty <strong>{{ timestamp|date:"d.m.Y H:i" }}</strong>, jolloin 
		  	ennakkoilmoituksen on jättänyt <strong>{{ num_submitted }}</strong> ehdokasta. 
		  </p>
		
	    </div>
	 </div>
		 
		
	 	<div class="row-fluid graph-container">
	 	  <div class="span6">
	 	  	<h5>Ennakkoilmoittaneiden osuus kunnittain</h5>
	 		<div id="map"></div>
		  </div>
		  
		  <div class="span6">
			  <div style="position: relative; margin: 10px 0 10px 0;">
			  	<h5>Ennakkoilmoitusten kertyminen, <span class="muni-selection"></span></h5>
			    <div id="party-graph"></div>
			    <div id="party-legend"></div>
			  </div>
		  </div>
		  
		  <div class="span6">
			  <div style="position: relative">
			  	<h5>Ehdokkaiden lukumäärä puolueittain, <span class="muni-selection"></span></h5>
			    <div id="candidate-graph"></div>
			    <div id="candidate-legend"></div>
			  </div>
		  </div>
		</div>
  
  <div class="row-fluid">
  	<div class="span12">
	  		
	  	<h4>Ennakkoilmoituksen tehneiden ehdokkaiden osuus kunnittain</h4>  	
	  	
	  	<p>
	  		Vasemmalla oleva kartta näyttää prosentein kuink suuri osuus 
	  		kunkin kunnan ehdokkaista on tehnyt vaalirahoituksen 
	  		ennakkoilmoituksen. Viemällä osoittimen kunnan päälle päivittyvät
	  		oikealla olevat kuvaajat kyseisen kunnan tiedoilla. 
	  	</p>
	  	
	  	<p>
	  		Jotkin kunnat puuttuvat kokonaan kartalta, sillä niissä ei ole 
	  		virallisesti yhtään ehdokasta usein tulevien kuntaliitosten takia. 
	  		Esimerkiksi <a href="http://www.kerimaki.fi/index.php?tid=310">Kerimäen kunnan verkkosivuilla</a> kerrotaan: 
	  		
	  		<blockquote>
	  			Vuoden 2012 kunnallisvaalit toimitetaan uutta kuntajakoa 
	  			noudattaen ja siten äänioikeusrekisteriin on myös Kerimäen ja 
	  			Punkaharjun kunnan alueella asuvien kotikunnaksi merkitty 
	  			Savonlinna.
	  		</blockquote>
	  		
	  	</p>
	  	
	  	<hr />
	  	
		<h4>Milloin ehdokkaat ovat ilmoituksia jättäneet?</h4>
		  
		<p>
	  		Oikealla ylhäällä oleva kuvaaja kertoo, kuinka ennakkoilmoituksia 
	  		on kertynyt eri puolueiden ehdokkailta kunnallisvaalien lähestyessä.
	  		Ilmoituksia alettiin seurata 7.10.2012 ja seurantaa jatketaan
	  		vaaleihin asti. Vaalien jälkeen sivulle päivitetään valituksi 
	  		tulleiden vaalirahoitustiedot.
		</p>
		
		<hr />
		
		<h4>Kuinka paljon ehdokkaita on puolueittain?</h4>
		  
		<p>
	  		Oikealla alhaalla oleva kuvaaja näyttää kuinka paljon ehdokkaita
	  		eri puolueilla on maanlaajuisesti ja kunnittain. 
		</p>
	  	
	
	</div>
  </div>
{% endblock %}

